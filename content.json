{"meta":{"title":"Welcome My Blog","subtitle":"","description":"","author":"Mark Lee","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2024-07-27T07:23:59.388Z","updated":"2024-07-27T07:23:59.387Z","comments":true,"path":"images/assignment_to_attributes.html","permalink":"http://example.com/images/assignment_to_attributes.html","excerpt":"","text":""},{"title":"","date":"2024-05-28T11:45:54.420Z","updated":"2024-05-28T11:45:54.420Z","comments":true,"path":"images/README_CN.html","permalink":"http://example.com/images/README_CN.html","excerpt":"","text":"中国蚁剑 一剑在手，纵横无忧！ 中国蚁剑是一款开源的跨平台网站管理工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员。任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担并将追究其相关责任！ English &#x2F; 文档 &#x2F; 更新日志 开发栈 Electron ES6 dhtmlx Nodejs 以及其他在项目中调用到的库 中国蚁剑推崇模块化的开发思想，遵循开源，就要开得漂亮的原则，致力于为不同层次的人群提供最简单易懂、方便直接的代码展示及其修改说明，努力让大家可以一起为这个项目贡献出力所能及的点滴，让这款工具真正能让大家用得顺心、舒适，让它能为大家施展出最人性化最适合你的能力！ 软件截图 更多截图 快速入门参见文档 快速入门 如何贡献参见文档 支持蚁剑 致敬感谢 中国蚁剑的核心代码模板均改自伟大的中国菜刀，在此向作者感谢以及致敬！致敬每一位为网络安全做出点滴贡献的新老前辈！ 一路走来，得到了很多朋友的参与开发以及点滴赞助，在此感谢陪伴，感谢你们能让它越走越远！ 其它星链计划2.0 antSword 已经加入 404Team 404StarLink 2.0 - Galaxy 开源协议详情请查看 LICENSE"}],"posts":[{"title":"openEuler：系统服务的配置和管理","slug":"openEuler：系统服务的配置和管理","date":"2024-07-31T14:12:56.000Z","updated":"2024-07-31T14:18:10.012Z","comments":true,"path":"d78e2e2.html","permalink":"http://example.com/d78e2e2.html","excerpt":"","text":"Tag： #任务管理 #系统服务 #Linux 系统服务基本概念系统服务系统服务是在系统启动时候自启动的一些后台程序，主要负责一些系统必须的核心功能，如：网络服务，文件系统管理器，日志记录等等一些常见的系统服务包括： 网络服务：如SSH（远程登录）、HTTP服务器（如Apache）、DNS服务器（如BIND）等。 日志服务：如Syslog，用于记录系统和应用程序的日志信息。 文件系统服务：如NFS（网络文件系统），允许在不同主机之间共享文件。 时间同步服务：如NTP（网络时间协议），用于同步系统时间。 守护进程与系统服务的概念区分 守护进程是一种脱离终端，在后台运行的进程 这些后台运行的进程其中一些提供系统服务 总的来说守护进程是一个更广泛的概念，因为守护进程仍可能提供一些非系统的服务 系统和服务管理器 — systemd简介systemd 设计目标是提供一套完整的系统启动和管理的解决方案 根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。 系统管理现在 systemd 已经成为很多发行版的标准配置使用 systemctl --version 查看 systemd 的版本 123[root@localhost ~]# systemctl --versionsystemd 249 (v249-52.oe2203sp2)+PAM +AUDIT +SELINUX -APPARMOR +IMA -SMACK +SECCOMP +GCRYPT +GNUTLS -OPENSSL +ACL +BLKID -CURL -ELFUTILS -FIDO2 +IDN2 -IDN -IPTC +KMOD -LIBCRYPTSETUP +LIBFDISK +PCRE2 -PWQUALITY +P11KIT -QRENCODE +BZIP2 +LZ4 +XZ +ZLIB -ZSTD +XKBCOMMON +UTMP +SYSVINIT default-hierarchy=legacy systemd 功能强大体系复杂，下图为 systemd 架构图 Unitsystemd 开启和监督服务是基于 Unit 概念不同的系统资源对应不同的 Unit，Unit 分为 12 类： Service unit：系统服务 Target unit：多个 Unit 构成的一个组 Device Unit：硬件设备 Mount Unit：文件系统的挂载点 Automount Unit：自动挂载点 Path Unit：文件或路径 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot Unit：Systemd 快照，可以切回某个快照 Socket Unit：进程间通信的 socket Swap Unit：swap 文件 Timer Unit：定时器 systemctl list-units命令可以查看当前系统的所有 Unit Unit的配置文件Unit 依赖关系Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。 存放配置文件的目录 Systemd 默认从目录/etc/systemd/system/读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录/usr/lib/systemd/system/，真正的配置文件存放在那个目录。 符号链接可以简单理解为一个副本，或者类比为 Windows 中的快捷方式 配置文件的格式以下面文件内容为例 12345678910111213141516[root@localhost system]# cat cron.service[Unit]Description=Command SchedulerAfter=auditd.service nss-user-lookup.target systemd-user-sessions.service time-sync.target ypbind.service autofs.service[Service]EnvironmentFile=/etc/sysconfig/crondExecStart=/usr/sbin/crond -n $CRONDARGSExecReload=/bin/kill -URG $MAINPIDKillMode=processRestart=on-failureRestartSec=30s[Install]WantedBy=multi-user.targetAlias=cron.service 配置文件主要分为三个区块 [ Unit ] 区块定义单元的元数据和依赖关系： Description：描述单元的简要信息。 Documentation：相关文档的URL。 After：指定此单元应在列出的其他单元启动后启动。 [ Service ] 区块该区块只有 .service 服务单元有，定义其行为和属性 EnvironmentFile：指定一个环境变量文件，这里是/etc/sysconfig/crond。 ExecStart：定义启动服务的命令，这里是/usr/sbin/crond -n $CRONDARGS，其中$CRONDARGS是从环境文件中读取的变量。 ExecReload：定义重新加载服务配置时执行的命令，这里是/bin/kill -URG $MAINPID。 KillMode：定义如何终止服务，这里是process，表示杀死主进程和子进程。 Restart：定义重启策略，这里是on-failure，表示在服务失败时重启。 RestartSec：定义重启前的等待时间，这里是30秒。 [ Install ] 区块 WantedBy：定义此服务在哪些目标单元下启用，这里是multi-user.target。 Alias：定义此服务的别名，这里是cron.service。 挂载和自动挂载点管理Systemd 监控和管理挂载和自动挂载点。Systemd 使用 _mount 单元作为挂载点 ，自动挂载单元用于自动挂载点_。 管理系统服务systemd 管理任务组，分配资源，跟踪和管理进程的生命周期是依据 cgroup 特性的，可见文章 [[浅谈 Cgroups 和 systemd]] systemd 的命令组systemd 不是一个命令，而是一组命令 systemctlsystemctl 是 systemd 的主命令，用于系统管理 1234567891011121314151617181920# 重启系统$ sudo systemctl reboot# 关闭系统，切断电源$ sudo systemctl poweroff# CPU停止工作$ sudo systemctl halt# 暂停系统$ sudo systemctl suspend# 让系统进入冬眠状态$ sudo systemctl hibernate# 让系统进入交互式休眠状态$ sudo systemctl hybrid-sleep# 启动进入救援状态（单用户状态）$ sudo systemctl rescue Unit管理对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。 123456789101112131415161718192021222324252627282930 # 立即启动一个服务$ sudo systemctl start apache.service# 立即停止一个服务$ sudo systemctl stop apache.service# 重启一个服务$ sudo systemctl restart apache.service# 杀死一个服务的所有子进程$ sudo systemctl kill apache.service# 重新加载一个服务的配置文件$ sudo systemctl reload apache.service# 重载所有修改过的配置文件$ sudo systemctl daemon-reload# 显示所有服务$ systemctl list-units --type service# 显示某个 Unit 的所有底层参数$ systemctl show httpd.service# 显示某个 Unit 的指定属性的值$ systemctl show -p CPUShares httpd.service# 设置某个 Unit 的指定属性$ sudo systemctl set-property httpd.service CPUShares=500 systemd-analyzesystemd-analyze 命令用于查看启动耗时 123systemd-analyzeStartup finished in 855ms (kernel) + 3.890s (initrd) + 9.291s (userspace) = 14.037s multi-user.target reached after 3.277s in userspace 12345678910# 查看启动耗时$ systemd-analyze # 查看每个服务的启动耗时$ systemd-analyze blame# 显示瀑布状的启动过程流$ systemd-analyze critical-chain# 显示指定服务的启动流$ systemd-analyze critical-chain atd.service hostnamectlhostnamectl命令用于查看当前主机的信息。 1234567891011121314# 显示当前主机的信息$ sudo hostnamectl Static hostname: n/a Transient hostname: localhost Icon name: computer-vm Chassis: vm Machine ID: 3af2603ba85e4b9998585459a851f47a Boot ID: fe23723dd9ee439581cc046701c0c6d0 Virtualization: kvm Operating System: openEuler 22.03 (LTS-SP2) Kernel: Linux 5.10.0-153.12.0.92.oe2203sp2.x86_64 Architecture: x86-64 Hardware Vendor: Tencent Cloud Hardware Model: CVM 12# 设置主机名。$ sudo hostnamectl set-hostname rhel7 任务管理cron &amp; crontab “Cron”一词来自于希腊语中的”kronos”（Κρόνος），意为时间或期限。 关键概念 cron：cron 是一个守护进程，负责进行周期性的调度 crontab：这里有两个含义： 负责管理 cron 调度的工具 cron 调度的配置文件,每个用户可以有自己的 crontab 文件，通常存储在 /var/spool/cron/ 目录下，以用户名命名。这些文件包含了用户定义的定时任务列表。 cron 运行机制 守护进程启动： 系统启动时，cron 守护进程会作为后台进程启动，并持续运行监听任务的执行需求。 定时检查： Cron 守护进程每分钟检查一次预定任务的执行时间，即使系统时间发生变化，也会确保按照新的时间执行任务。 读取 crontab 文件： Cron 会读取系统中每个用户的 crontab 文件，这些文件通常存储在 /var/spool/cron/ 目录中，文件名与用户名对应。 执行任务： 当 cron 执行任务时，它会以预定义的用户环境变量运行命令。这意味着任务的执行环境可能会与手动执行命令时稍有不同，例如路径变量和其他环境设置。 记录日志： 每次任务执行完成后，cron 会将执行的结果记录到系统日志中，例如 /var/log/syslog 或 /var/log/cron。这些日志记录对于监视任务执行情况和排查问题非常重要。 crontab 配置文件语法我们查看 /etc/crontab 配置文件可以看到语法为： * * * * * user-name command_to_execute crontab 配置工具命令格式 crontab -u user_name -e -l -r -e 编辑配置文件 -l 列出配置文件 -r 删除配置文件内容 demo 实现简单的定时工具编写执行脚本将当前时间输出到 timer.txt 文件 编辑 crontab 文件使用 crontab -e 编写 crontab 文件每分钟执行脚本，并将错误输出和标准输出重定向 查看结果每分钟 1 秒时候，时间被写入 timer.txt查看我们刚才编写的定时程序 使用 &amp; 将程序放在后台运行在指令最后加上 &amp; 符号，将该程序放在后台运行，该进程的父进程为当前 bash demo编写 python 程序，每十秒钟将时间写入 timer.txt 文件 12345678910111213141516import datetime as dtimport timefile_path = &quot;/root/openEuler_study/timer.txt&quot;while(1): current_time = dt.datetime.now() time_str = current_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;) with open(file_path,&quot;+a&quot;) as file: file.write(time_str + &quot;\\n&quot;) time.sleep(10) 将该程序放在后台运行 [ 1 ] 中数字代表 jobs 编号，后面数字是该进程 pid 使用 ps -l 查看完整信息 我们可以看到该进程的父进程为当前 bash 查看 timer.txt 文件是否被正确写入 每十秒写入一次 结束该进程我们可以使用 kill %[josb ID] or kill [PID] At 实现定时任务管理1. 用户提交任务当用户通过 at 命令提交任务时，系统会记录下任务的具体执行时间和需要执行的命令。命令示例如下：或者使用 echo 提交任务echo &quot;sh /path/to/your/script.sh&quot; | at 15:30 2. 任务存储任务提交后，at 命令会将任务信息存储在一个指定目录中，通常是 /var/spool/at。每个任务会生成一个文件，文件名包含了任务的执行时间和其他信息。 3. 任务调度系统中有一个守护进程 atd，它负责定期检查任务存储目录中的任务文件。atd 会读取这些文件，解析任务的执行时间，并将任务排入调度队列。 4. 任务执行当 atd 检测到某个任务的执行时间到了，它会读取该任务文件中的命令，并在指定的时间执行这些命令。执行的过程类似于用户在命令行直接输入这些命令。 nohub 命令 参考资料 Linux 系统服务和守护进程 Systemd 入门教程：命令篇 crontab使用说明【一文搞懂Linux定时任务Crontab】","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"openEuler","slug":"Linux/openEuler","permalink":"http://example.com/categories/Linux/openEuler/"}],"tags":[{"name":"任务管理","slug":"任务管理","permalink":"http://example.com/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"系统服务","slug":"系统服务","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"}]},{"title":"openEuler：物理存储及逻辑卷管理","slug":"openEuler：物理存储及逻辑卷管理","date":"2024-07-28T14:21:39.000Z","updated":"2024-07-31T14:18:10.017Z","comments":true,"path":"2d7002e4.html","permalink":"http://example.com/2d7002e4.html","excerpt":"","text":"磁盘存储挂载与使用磁盘挂载磁盘挂载（mounting）是指在操作系统中将一个存储设备（如硬盘、SSD、光盘、U盘等）连接到文件系统，使其可以被系统和用户访问和使用。挂载后，存储设备上的文件和目录将会出现在指定的挂载点（通常是一个空的目录）下，用户可以通过这个挂载点来访问和操作这些文件和目录。 使用mount查看磁盘挂载信息123456789101112131415161718192021222324252627282930313233[root@localhost yum.repos.d]# mountproc on /proc type proc (rw,nosuid,nodev,noexec,relatime)sysfs on /sys type sysfs (rw,nosuid,nodev,noexec,relatime,seclabel)devtmpfs on /dev type devtmpfs (rw,nosuid,seclabel,size=4096k,nr_inodes=1048576,mode=755)securityfs on /sys/kernel/security type securityfs (rw,nosuid,nodev,noexec,relatime)tmpfs on /dev/shm type tmpfs (rw,nosuid,nodev,seclabel)devpts on /dev/pts type devpts (rw,nosuid,noexec,relatime,seclabel,gid=5,mode=620,ptmxmode=000)tmpfs on /run type tmpfs (rw,nosuid,nodev,seclabel,size=299212k,nr_inodes=819200,mode=755)tmpfs on /sys/fs/cgroup type tmpfs (ro,nosuid,nodev,noexec,seclabel,size=4096k,nr_inodes=1024,mode=755)cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)none on /sys/fs/bpf type bpf (rw,nosuid,nodev,noexec,relatime,mode=700)cgroup on /sys/fs/cgroup/rdma type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,rdma)cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,net_cls,net_prio)cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpuset)cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,freezer)cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,pids)cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,hugetlb)cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,cpu,cpuacct)cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,perf_event)cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,memory)cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,blkio)cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,seclabel,devices)/dev/mapper/openeuler-root on / type ext4 (rw,relatime,seclabel)selinuxfs on /sys/fs/selinux type selinuxfs (rw,nosuid,noexec,relatime)systemd-1 on /proc/sys/fs/binfmt_misc type autofs (rw,relatime,fd=35,pgrp=1,timeout=0,minproto=5,maxproto=5,direct,pipe_ino=14884)hugetlbfs on /dev/hugepages type hugetlbfs (rw,relatime,seclabel,pagesize=2M)mqueue on /dev/mqueue type mqueue (rw,nosuid,nodev,noexec,relatime,seclabel)debugfs on /sys/kernel/debug type debugfs (rw,nosuid,nodev,noexec,relatime,seclabel)tracefs on /sys/kernel/tracing type tracefs (rw,nosuid,nodev,noexec,relatime,seclabel)fusectl on /sys/fs/fuse/connections type fusectl (rw,nosuid,nodev,noexec,relatime)configfs on /sys/kernel/config type configfs (rw,nosuid,nodev,noexec,relatime)tmpfs on /tmp type tmpfs (rw,nosuid,nodev,seclabel,size=748028k,nr_inodes=1048576)/dev/vda1 on /boot type ext4 (rw,relatime,seclabel) 信息的解释 设备名：例如 /dev/sda1、/dev/sda2、/dev/sdb1 等，表示挂载的设备或分区。 挂载点：例如 /、/home、/mnt/mydisk 等，表示设备挂载到的目录。 文件系统类型：例如 ext4、iso9660、squashfs 等，表示设备使用的文件系统类型。 挂载选项：例如 rw、relatime、ro、nosuid 等，表示挂载时使用的选项。 fdisk -l查看磁盘信息1234567891011121314151617181920212223[root@localhost boot]# fdisk -lDisk /dev/vda：40 GiB，42949672960 字节，83886080 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节磁盘标签类型：dos磁盘标识符：0x849d8593设备 启动 起点 末尾 扇区 大小 Id 类型/dev/vda1 * 2048 2099199 2097152 1G 83 Linux/dev/vda2 2099200 83886079 81786880 39G 8e Linux LVMDisk /dev/mapper/openeuler-root：36.94 GiB，39665532928 字节，77471744 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节Disk /dev/mapper/openeuler-swap：2.05 GiB，2206203904 字节，4308992 个扇区单元：扇区 / 1 * 512 = 512 字节扇区大小(逻辑/物理)：512 字节 / 512 字节I/O 大小(最小/最佳)：512 字节 / 512 字节 使用df -h查看磁盘挂载，容量，利用率123456789[root@localhost boot]# df -h文件系统 容量 已用 可用 已用% 挂载点devtmpfs 4.0M 0 4.0M 0% /devtmpfs 731M 0 731M 0% /dev/shmtmpfs 293M 30M 263M 11% /runtmpfs 4.0M 0 4.0M 0% /sys/fs/cgroup/dev/mapper/openeuler-root 37G 1.8G 33G 6% /tmpfs 731M 0 731M 0% /tmp/dev/vda1 974M 151M 756M 17% /boot 磁盘分区 硬盘分区是使用分割编辑器（partition editor）在磁盘上划分几个逻辑部分，碟片一旦划分成数个分割（Partition），不同类的目录与文件可以存储进不同的分割。 磁盘分区主要有 MBR 和 GPT 两种格式，两种不同的磁盘分区表标准 使用 lsblk 列出系统上所有磁盘列表12345678[root@localhost boot]# lsblkNAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTSsr0 11:0 1 223.5M 0 rom vda 252:0 0 40G 0 disk ├─vda1 252:1 0 1G 0 part /boot└─vda2 252:2 0 39G 0 part ├─openeuler-root 253:0 0 36.9G 0 lvm / └─openeuler-swap 253:1 0 2.1G 0 lvm [SWAP] 从输出信息来看，主要分为两个sr0，vda装置，vda中分为两个分区vda1，vda2，vda2中还有 LVM 产生的文件系统 信息解释 NAME：装置文件名，会省略 &#x2F;dev 等前导目录 MAJ:MIN：其实核心认识的装置都是通过这两个代码来熟悉的，分别是：主要:次要 装置 RM：是否为颗拆卸装置（removable device）。如光盘、USB 磁盘等 SIZE：容量 RO：是否为只读 TYPE：磁盘 disk、分区槽 partition、只读存储器 rom MOUTPOINT：挂载点 分区架构 主分区 扩展分区（它本身不能存储数据，而是一个容器，可以包含多个逻辑分区） 逻辑分区1 逻辑分区2 逻辑分区3 分区命名规则/dev/vd&#123;a-z&#125;&#123;number&#125; /dev/ 设备名称 vd 设备类型（ hd/sd ) &#123;a-z&#125; 设备序号 &#123;number&#125; 分区编号 磁盘分区方案MBR使用 parted /dev/vda print 列出磁盘的分区表类型与分区信息 12345678910[root@localhost boot]# parted /dev/vda print型号：Virtio 块设备 (virtblk)磁盘 /dev/vda：42.9GB扇区大小 (逻辑/物理)：512B/512B分区表：msdos磁盘标志：编号 起始点 结束点 大小 类型 文件系统 标志 1 1049kB 1075MB 1074MB primary ext4 启动 2 1075MB 42.9GB 41.9GB primary lvm 我们看到分区表类型 msdos 是指MBR分区表 — 使用 fdisk 分区工具，执行以下操作对某个磁盘进行操作 1fdisk /dev/vda GPT GPT 分区标准摆脱了 MBR 的最大支持 2TB 的限制，支持更大的磁盘容量 没有主分区和逻辑分区的区别 每一个分区有一个全局标识符（GUID） 使用 gdisk 工具 parted 分区工具parted /dev/vda 进入交互模式 fstab 介绍静态存储了磁盘存储挂载信息，在系统启动时，会自动调取该文件进行磁盘挂载，这样就不需要手动进行挂载 fstab文件格式1234 # &lt;file system&gt; &lt;mount point&gt; &lt;type&gt; &lt;options&gt; &lt;dump&gt; &lt;pass&gt;/dev/sda1 /boot ext4 defaults 1 2/dev/mapper/root / ext4 defaults 0 1UUID=12345678-9ab /home ext4 defaults 0 2 &lt;file system&gt;：文件系统的设备路径或UUID &lt;mount point&gt;：文件系统要挂载到的路径 &lt;type&gt;：文件系统类型 &lt;options&gt;：挂载选项，例如defaults、noauto、ro、rw等 &lt;dump&gt;：用于备份工具的备份级别，默认为0 &lt;pass&gt;：用于fsck工具的文件系统检查顺序，默认为0（不检查） 逻辑卷管理（LVM） LVM 是 Linux 系统对磁盘分区的一种管理机制，是在磁盘分区之上建立一个逻辑层，这个逻辑层让多个硬盘或者分区看起来像一块逻辑硬盘，然后将这块逻辑硬盘分成逻辑卷之后使用，从而大大提高了分区的灵活性。 基本概念 PE（Physical Extend）：物理单元，能被 LVM 寻址的最小单元 PV（Physical Volume）：物理卷，即实际存在的分区 VG（Volume Group）：卷组，一个或多个物理卷组成卷组，可以将卷组想象成为一个新的逻辑磁盘 LV（Logical Volume）：逻辑卷，将卷组重新分配为多个逻辑卷，是用户实际使用的逻辑设备 使用 LVM 创建管理逻辑卷物理卷操作 创建物理卷命令为 pvcreate [option] devname详细用法使用 pvcreate --help 查看 查看物理卷信息命令为 pvdisplay [option] devname ，我们可以看到信息包括如下12345678910--- Physical volume --- PV Name /dev/vda2 VG Name openeuler PV Size &lt;39.00 GiB / not usable 3.00 MiB Allocatable yes (but full) PE Size 4.00 MiB Total PE 9983 Free PE 0 Allocated PE 9983 PV UUID yoL1lh-t5IG-VVPT-13dO-LxVD-LXvk-NnkUfE 修改物理卷信息命令为 pvchange [option] devname详细用法使用 pvchange --help 查看 删除物理卷命令为 pvremove [option] devname 卷组操作 创建卷组 vgcreate [option] vgname pvname ... 查看卷组 vgdisplay [option] [vgname] 修改卷组属性 vgchange [option] vgname 扩展卷组 vgextend [option] vgname pvname ... 收缩卷组 vgreduce [option] vgname pvname ... 删除卷组 vgremove [option] vgname 逻辑卷操作 创建逻辑卷 lvcreate [option] -n lvname vgname 查看逻辑卷 lvdisplay [option] [lvname] 调整逻辑卷大小 lvresize [option] lvname 扩展逻辑卷 lvextend [option] lvname 收缩逻辑卷 lvreduce [option] lvname 删除逻辑卷 lvremove [option] lvname 参考文章：- Linux LVM 逻辑卷管理器","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"openEuler","slug":"Linux/openEuler","permalink":"http://example.com/categories/Linux/openEuler/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"系统存储","slug":"系统存储","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8/"},{"name":"openEuler","slug":"openEuler","permalink":"http://example.com/tags/openEuler/"}]},{"title":"使用vscode连接openEuler服务器","slug":"使用vscode连接openEuler服务器","date":"2024-07-24T14:20:39.000Z","updated":"2024-07-31T14:18:10.015Z","comments":true,"path":"80f76920.html","permalink":"http://example.com/80f76920.html","excerpt":"","text":"本地主机准备 Remote - SSH： 服务器准备官方文档提供的提前准备 Distribution Base Requirements Remote - SSH Requirements Notes General kernel &gt;&#x3D; 4.18, glibc &gt;&#x3D;2.28, libstdc++ &gt;&#x3D; 3.4.25, tar OpenSSH server, bash, and curl or wget Run ldd --version to check the glibc version. Run strings /usr/lib64/libstdc++.so.6 | grep GLIBCXX to see if libstdc++ 3.4.25 is available. General for Arm32 libatomic1 No additional requirements. Ubuntu 20.04+, Debian 10+, Raspberry Pi OS Buster&#x2F;10+ and downstream distributions libc6 libstdc++6 ca-certificates tar openssh-server bash and curl or wget Requires kernel &gt;&#x3D; 4.18, glibc &gt;&#x3D; 2.28, libstdc++ &gt;&#x3D; 3.4.25. RHEL &#x2F; CentOS 8+ glibc libgcc libstdc++ ca-certificates tar openssh-server bash and curl or wget Requires kernel &gt;&#x3D; 4.18, glibc &gt;&#x3D; 2.28, libstdc++ &gt;&#x3D; 3.4.25. Alpine Linux 3.16+ musl libgcc libstdc++. musl &gt;&#x3D; 1.2.3, glibc not required. Not yet supported. Supported in Dev Containers and WSL. Extensions installed in the container may not work due to glibc dependencies in extension native code. openSUSE Leap &#x2F; SUSE Linux Enterprise 15+ glibc libgcc_s1 libstdc++6 ca-certificates gzip tar curl or wget Requires kernel &gt;&#x3D; 4.18, glibc, libstdc++6 针对openEuler的准备缺少tar 解压工具检查是否缺少tar解压工具 12[root@localhost ~]# tar-bash: tar：未找到命令 使用以下命令安装tar 1dnf install tar 端口转发未开启 我们查看sshd 服务配置文件1[root@localhost ~]# cat /etc/ssh/sshd_config 找到以下两个配置12AllowTcpForwarding noAllowAgentForwarding no 将 ‘ no ‘改为’ yes ‘12AllowTcpForwarding yesAllowAgentForwarding yes 重启sshd 服务1systemctl restart sshd.service","categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"openEuler","slug":"Linux/openEuler","permalink":"http://example.com/categories/Linux/openEuler/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"openEuler","slug":"openEuler","permalink":"http://example.com/tags/openEuler/"}]}],"categories":[{"name":"Linux","slug":"Linux","permalink":"http://example.com/categories/Linux/"},{"name":"openEuler","slug":"Linux/openEuler","permalink":"http://example.com/categories/Linux/openEuler/"}],"tags":[{"name":"任务管理","slug":"任务管理","permalink":"http://example.com/tags/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86/"},{"name":"系统服务","slug":"系统服务","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"},{"name":"Linux","slug":"Linux","permalink":"http://example.com/tags/Linux/"},{"name":"系统存储","slug":"系统存储","permalink":"http://example.com/tags/%E7%B3%BB%E7%BB%9F%E5%AD%98%E5%82%A8/"},{"name":"openEuler","slug":"openEuler","permalink":"http://example.com/tags/openEuler/"}]}